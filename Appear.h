//
//  k-Fan matching and training code, as described in the paper:
//
//    Crandall, Felzenszwalb, Huttenlocher, "Spatial 
//      Priors for Part-based Recognition using Statistical Models," CVPR 2005.
//     
//
//  Author: David Crandall, 2003-2005
//          crandall@cs.cornell.edu
//
//  Please do not redistribute this code.
//
//
// 
// 
#ifndef __APPEAR_H__
#define __APPEAR_H__

#include <DImage.h>
#include <DMultiDMatrix.h>
#include <iostream>
#include <fstream>
#include <vector>

template<class T>
class AppearModel
{
 public:
  AppearModel() {}
  ~AppearModel() {}
  
  virtual _DMultiDMatrix<T> run_model(DPlane &edge_map) {throw std::string("ended up in base class"); }
  virtual _DMultiDMatrix<T> run_model(unsigned char *edge_map, int rows, int cols) {throw std::string("ended up in base class"); }

  virtual int rows() {throw std::string("ended up in base class");}
  virtual int cols() {throw std::string("ended up in base class"); }

  unsigned char *embed_img(unsigned char *in_im, int rows, int cols,
				   int new_rows, int new_cols);

  virtual void write_model(std::ostream &os) { throw std::string("ended up in base class"); }

  friend std::ostream &operator<<(std::ostream &os, AppearModel &appear)
  {
    appear.write_model(os);
    return os;
  }
};

template<class T>
class Appear : public AppearModel<T>
{
 public:

  Appear() {}

  Appear(char *fname)
    {
      _DMultiDMatrix<T> _fg_model;
      _DMatrix<T> _bg_model;

      std::ifstream ifs;
      ifs.open(fname, std::ios::in);

      if(!ifs.is_open())
	throw std::string("File not found: ") + std::string(fname);

      char temp[1024];
      ifs.getline(temp, 1024);

      ifs >> _bg_model;
      ifs >> _fg_model;

      ifs.close();
      
      initialize(_fg_model, _bg_model);
    }

  friend std::ostream &operator<<(std::ostream &os, Appear &appear)
  {
    os << "this is an appearance model file generated by match.cpp" << std::endl;

    os << appear.__bg_model << std::endl;
    os << appear.__fg_model << std::endl;

    return os;
  }

  virtual void write_model(std::ostream &os)
  {
    os << (*this);
  }

  Appear(const _DMultiDMatrix<T> &fg_model, const _DMatrix<T> &bg_model)
    {
      initialize(fg_model, bg_model);
    }



  void initialize(const _DMultiDMatrix<T> &fg_model, const _DMatrix<T> &bg_model)
    {
      __fg_model = fg_model;
      __bg_model = bg_model;

      part_count = fg_model.get_dims(0);
      dir_count = fg_model.get_dims(1);

      log_fg_model = fg_model;
      log_bg_model = bg_model;

      T *cp = log_bg_model[0];
      for(int i=0; i<bg_model.cols(); i++, cp++)
	*cp = (T) log(*cp);

      for(int p=0; p<part_count; p++)
	for(int d=0; d<dir_count; d++)
	  {
	    cp = (log_fg_model.get(p,d))[0];
	    for(int i=0; i<fg_model.rows() * fg_model.cols(); i++, cp++)
	      *cp = (T)log(*cp);
	  }
	
      log_back_probs_diff = log_fg_model;

      for(int p=0; p<part_count; p++)
	{
	  int f_rows = log_fg_model.rows(), f_cols = log_fg_model.cols();

	  for(int d=0; d<dir_count; d++)
	    {
	      T *out_cp = (log_back_probs_diff.get(p,d))[0];
	      T *in_cp = (log_fg_model.get(p,0))[0];
	      T log_bg_model_0_d_minus_0_0 = log_bg_model[0][d] -
		log_bg_model[0][0];

	      for(int i=0; i<f_rows; i++)
		for(int j=0; j<f_cols; j++, out_cp++, in_cp++)
		  {
		    *out_cp = (*out_cp - *in_cp) - 
		      (log_bg_model_0_d_minus_0_0);
		  }
	    }
	}


    }

  virtual int rows() { return __fg_model.rows(); }
  virtual int cols() { return __fg_model.cols(); }

  virtual _DMultiDMatrix<T> run_model(_DPlane<unsigned char> &edge_map);
  virtual _DMultiDMatrix<T> run_model(unsigned char *edge_map, int rows, int cols);

  _DMultiDMatrix<T> run_model_with_rotation(_DPlane<unsigned char> &edge_map, double min_angle, double max_angle,
					 double angle_step);
  _DMultiDMatrix<T> run_model_with_rotation(unsigned char *img, int row, int col, double min_angle, double max_angle,
					 double angle_step);

  _DMultiDMatrix<T> run_model_rotation_invariant_exhaustive(const _DPlane<unsigned char> &img, double min_angle, double max_angle, double angle_step);
  _DMultiDMatrix<T> run_model_rotation_invariant_exhaustive(unsigned char *img, int rows, int cols, double min_angle, double max_angle, double angle_step);

  // protected:
  _DMultiDMatrix<T> log_fg_model, log_back_probs_diff;
  _DMultiDMatrix<T> __fg_model;
  _DMatrix<T> __bg_model;
  _DMatrix<T> log_bg_model;

  int dir_count, part_count;

};


template<class T>
class Appear_RotInvariant : public Appear<T>
{
 public:

  Appear_RotInvariant() {}

  Appear_RotInvariant(char *fname, double _min_angle, double _max_angle, double _angle_step) : Appear<T>(fname)
    {
      min_angle = _min_angle;
      max_angle = _max_angle;
      angle_step = _angle_step;
      angle_count = int((max_angle - min_angle) / angle_step + 1);

      int ang=0;
      for(double theta = min_angle; theta <= max_angle; theta+=angle_step, ang++)
	{
	  _DPlane<T> tmp_p = (_DPlane<T>((Appear<T>::__fg_model.get(0,0)))).rotate_image(theta);

	  _DMultiDMatrix<T> tmp(4, Appear<T>::part_count, Appear<T>::dir_count, tmp_p.rows(), tmp_p.cols());

	  for(int i=0; i<Appear<T>::part_count; i++)
	    for(int j=0; j<Appear<T>::dir_count; j++)
	      {
		_DPlane<T> t(Appear<T>::__fg_model.get(i,j));
		tmp.get(i,j) = t.rotate_image(theta, Appear<T>::__bg_model[0][j]);
	      }

	  appears.push_back(Appear<T>(tmp, Appear<T>::__bg_model));
	}

    }

  //  DMultiDMatrix run_model(DPlane &edge_map);
  virtual _DMultiDMatrix<T> run_model(unsigned char *edge_map, int rows, int cols)
  {
    int ang=0;
        _DMultiDMatrix<T> result;


	std::cout << "USING ROT INVARIANCE" << std::endl;
    for(double theta=min_angle; theta<=max_angle; theta+=angle_step, ang++)
      {
	_DMultiDMatrix<T> aaa=appears[ang].run_model(edge_map, rows, cols);
	if(ang == 0)
	  {
	    result =     _DMultiDMatrix<T>(3, aaa.planes(), aaa.rows(), aaa.cols());
	    result = -1e100;
	  }

	/*	char s[1024];
	for(int p=0; p<aaa.planes(); p++)
	  {
	    sprintf(s, "rot_%d_%d.dat", ang, p);
	    FILE *fp = fopen(s, "wb");
	    fprintf(fp, "%d", aaa.rows());
	    fprintf(fp, "%d", aaa.cols());
	    fwrite(aaa.get(p)[0], sizeof(T), aaa.rows()*aaa.cols(), fp);
	    fclose(fp);
	    sprintf(s, "apps_%d_%d.dat", ang, p);
	    fp = fopen(s, "wb");
	    fprintf(fp, "%d", appears[ang].__fg_model.rows());
	    fprintf(fp, "%d", appears[ang].__fg_model.cols());
	    fwrite(appears[ang].__fg_model.get(p,0)[0], sizeof(T), appears[ang].__fg_model.rows()*appears[ang].__fg_model.cols(), fp);
	    fclose(fp);
	    if(p==4 && ang==0)
	      std::cout << appears[ang].__fg_model.get(p,0) << std::endl;
	  }
	*/
	result = pointwise_max(aaa, result);

      }

    return result;
  }
  virtual int rows() { return Appear<T>::__fg_model.rows(); }
  virtual int cols() { return Appear<T>::__fg_model.cols(); }

  double min_angle, max_angle, angle_step;
  int angle_count;
  std::vector<Appear<T> > appears;
  Appear<T> base_appear;
};


#endif
