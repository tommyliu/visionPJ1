//
//  k-Fan matching and training code, as described in the paper:
//
//    Crandall, Felzenszwalb, Huttenlocher, "Spatial 
//      Priors for Part-based Recognition using Statistical Models," CVPR 2005.
//     
//
//  Author: David Crandall, 2003-2005
//          crandall@cs.cornell.edu
//
//  Please do not redistribute this code.
//
//
// 
// 
#include <KFan.h>
#include <DistanceTransform.h>
#include <math.h>
#include<iostream>
#include <fstream>
#include <DPlane.h>
#include <DMultiDMatrix.h>
//#include <DBoxMinTransform.h>
using namespace std;
/*
#ifndef DEBUG
std::ostream dout(std::cout.rdbuf()); 
#else 
std::ostream dout(static_cast<std::streambuf*>(0)); 
#endif 
*/
extern std::ostream dout;

extern int this_proc;

////////////////////////
template<class T>
void KFan<T>::load_params(char *fname)
{
  // Read in parameters
  ifstream ifs;
  ifs.open(fname, ios::in);

  if(!ifs.is_open())
    throw std::string("File not found: ") + std::string(fname);

  char temp[1024];
  ifs.getline(temp, 1024);

  ifs >> parts_count >> K;

  int a, b;
  // load dimensions of distparts matrix, should be 1 1 
  ifs >> dist_parts;


  dist_parts=dist_parts-1;

  ifs >> dist_sigmas;
  ifs >> dist_means;
  ifs >> cond_sigmas;
  ifs >> cond_means;
  ifs >> cond_mus_x2;

  ifs.close();

}

template<class T>
std::ostream &operator<<(std::ostream & ofs, KFan<T> &kfan)
{
  ofs << "kfan model file generated by match.cpp" << endl;
  ofs << kfan.parts_count << " " << kfan.K << endl;

  ofs << kfan.dist_parts+1 << endl;
  ofs << kfan.dist_sigmas << endl << kfan.dist_means << endl;
  ofs << kfan.cond_sigmas << endl << kfan.cond_means << endl;
  ofs << kfan.cond_mus_x2 << endl;

  return ofs;
}


//////////////////////// 0 Fan
template<class T>
pair<T, _DMatrix<T> > K_0Fan<T>::do_matching(_DMultiDMatrix<T> &cost_maps)
{

  T best_costs[(int) KFan<T>::parts_count];
  _DMatrix<T> best_locations(KFan<T>::parts_count,2);
  T best_cost = -1e100;

  for(int i=0; i<KFan<T>::parts_count; i++)
    best_costs[i]=-1e100;

  for(int i=0; i<cost_maps.rows(); i++)
    for(int j=0; j<cost_maps.cols(); j++)
      {
	for(int p=0; p<KFan<T>::parts_count; p++)
	  {
	    if(cost_maps.get(p)[i][j] > best_costs[p])
	      {
		best_costs[p] = cost_maps.get(p)[i][j];
		best_locations[p][0] = i;
		best_locations[p][1] = j;
	      }
	  }
      }

  best_cost = 0;
  for(int i=0; i<KFan<T>::parts_count; i++)
    best_cost += best_costs[i];

  return pair<T, _DMatrix<T> >(best_cost, best_locations);
}


//////////////////////// 1 Fan
template<class T>
pair<T, _DMatrix<T> > K_1Fan<T>::do_matching(_DMultiDMatrix<T> &cost_maps)
{
  pair< _DPlane<T>, pair<_DPlane<short>, _DPlane<short> > > *dt_images
    = new pair<_DPlane<T> ,pair<_DPlane<short>, _DPlane<short> > >[KFan<T>::parts_count];
  _DistanceTransform<T, short> dt;

  for(int p=0; p<KFan<T>::parts_count; p++)
    {
      if(p != dist_part)
	{
	  _DMatrix<T> invsigmas = KFan<T>::cond_sigmas.get(p);
	  _DMatrix<T> invsigmas2 = invsigmas * 2.0;
	  dt_images[p] = dt.do_transform_2d(-cost_maps.get(p), invsigmas2);

	  T det_sigma = invsigmas[0][0] * invsigmas[1][1] - 
	    invsigmas[0][1] * invsigmas[1][0];
	  
	  dt_images[p].first = -dt_images[p].first
	    -(1/2.0)* 2.0 * log(2.0*M_PI) - 
	    (1 / 2.0) * log(det_sigma);
	}
      
    }

  T best_cost = -1e100;
  _DMatrix<T> best_locations(KFan<T>::parts_count,2);
  int best_row=0, best_col=0;

  for(int i=0; i<cost_maps.rows(); i++)
    for(int j=0; j<cost_maps.cols(); j++)
      {
	T cost = cost_maps.get(dist_part)[i][j];
	
	for(int p=0; p<KFan<T>::parts_count; p++)
	  {
	    if(p != dist_part)
	      {
		int i2 = (int)round(i + (KFan<T>::cond_means.get(p))[0][1]);
		int j2 = (int)round(j + (KFan<T>::cond_means.get(p))[0][0]);
		
		if(i2 < 0 || j2 < 0 || i2 >= cost_maps.rows() || 
		   j2 >= cost_maps.cols())
		  cost = -1e100;
		else
		  {
		    cost += dt_images[p].first[i2][j2];
		  }
	      }
	  }
	
	if(cost > best_cost)
	  {
	    best_cost = cost;
	    best_row = i;
	    best_col = j;
	  }
      }
  
  
  best_locations[dist_part][0]=best_row;
  best_locations[dist_part][1]=best_col;
  
  for(int p=0; p<KFan<T>::parts_count; p++)
    {
      if(p != dist_part)
	{
	  int i2 = (int)round(best_row + (KFan<T>::cond_means.get(p))[0][1]);
	  int j2 = (int)round(best_col + (KFan<T>::cond_means.get(p))[0][0]);
	  
	  if(i2 < 0) i2=0;
	  if(j2 < 0) j2=0;
	  if(i2 >= cost_maps.rows()) i2=cost_maps.rows()-1;
	  if(j2 >= cost_maps.cols()) j2=cost_maps.cols()-1;
      
	  best_locations[p][1] = dt_images[p].second.first[i2][j2];
	  best_locations[p][0] = dt_images[p].second.second[i2][j2];

	}
    }
  
  int p=dist_part;
  int i2 = (int)round(best_row + (KFan<T>::cond_means.get(p))[0][1]);
  int j2 = (int)round(best_col + (KFan<T>::cond_means.get(p))[0][0]);

  delete[] dt_images;

  return pair<T, _DMatrix<T> >(best_cost, best_locations);
}

///////////////////////////////////


//////////////////////// 1 Fan
/*
pair<double, DMatrix> K_1Fan<T>::do_matching_rotational_invariance(DMultiDMatrix &cost_maps, double min_angle, 
								double max_angle, double angle_step)
{
  int rot_count = (max_angle - min_angle)/angle_step + 1;

  _DMultiDMatrix<T> dt_images(4, rot_count, part_count, 0, 0);
  DMultiDMatrix row_locs(4, rot_count, part_count, 0, 0);
  DMultiDMatrix col_locs(4, rot_count, part_count, 0, 0);

  DistanceTransform dt;
  
  for(int p=0; p<parts_count; p++)
    {
      if(p != dist_part)
	{
	  pair< DPlane, pair<DPlane, DPlane> > dt_pair;

	  _DMatrix<T> invsigmas = KFan<T>::cond_sigmas.get(p);
	  _DMatrix<T> invsigmas2 = invsigmas * 2.0;
	  
	  dt_pair = dt.do_transform_2d(-cost_maps.get(p), invsigmas2);

	  T det_sigma = invsigmas[0][0] * invsigmas[1][1] - 
	    invsigmas[0][1] * invsigmas[1][0];
	  
	  dt_images[p].first = -dt_images[p].first
	    -(1/2.0)* 2.0 * log(2.0*M_PI) - 
	    (1 / 2.0) * log(det_sigma);
	}
      
    }

  T best_cost = -1e100;
  DMatrix best_locations(KFan<T>::parts_count,2);
  int best_row, best_col;

  for(int i=0; i<cost_maps.rows(); i++)
    for(int j=0; j<cost_maps.cols(); j++)
      {
	T cost = cost_maps.get(dist_part)[i][j];
	
	for(int p=0; p<KFan<T>::parts_count; p++)
	  {
	    if(p != dist_part)
	      {
		int i2 = (int)round(i + (KFan<T>::cond_means.get(p))[0][1]);
		int j2 = (int)round(j + (KFan<T>::cond_means.get(p))[0][0]);
		
		if(i2 < 0 || j2 < 0 || i2 >= cost_maps.rows() || 
		   j2 >= cost_maps.cols())
		  cost = -1e100;
		else
		  {
		    cost += dt_images[p].first[i2][j2];
		  }
	      }
	  }
	
	if(cost > best_cost)
	  {
	    best_cost = cost;
	    best_row = i;
	    best_col = j;
	  }
      }
  
  
  best_locations[dist_part][0]=best_row;
  best_locations[dist_part][1]=best_col;
  
  for(int p=0; p<KFan<T>::parts_count; p++)
    {
      if(p != dist_part)
	{
	  int i2 = (int)round(best_row + (KFan<T>::cond_means.get(p))[0][1]);
	  int j2 = (int)round(best_col + (KFan<T>::cond_means.get(p))[0][0]);
	  
	  if(i2 < 0) i2=0;
	  if(j2 < 0) j2=0;
	  if(i2 >= cost_maps.rows()) i2=cost_maps.rows()-1;
	  if(j2 >= cost_maps.cols()) j2=cost_maps.cols()-1;
      
	  best_locations[p][1] = dt_images[p].second.first[i2][j2];
	  best_locations[p][0] = dt_images[p].second.second[i2][j2];

	}
    }
  
  int p=dist_part;
  int i2 = (int)round(best_row + (KFan<T>::cond_means.get(p))[0][1]);
  int j2 = (int)round(best_col + (KFan<T>::cond_means.get(p))[0][0]);

  delete[] dt_images;

  return pair<T, DMatrix>(best_cost, best_locations);
}

*/





//////////////////////// 2 Fan


// sniped




#define DECLARE(x) \
  template class KFan<x>; \
  template class K_0Fan<x>; \
  template class K_1Fan<x>; \
  template std::ostream &operator<< <x>(std::ostream & ofs, KFan<x> &kfan);

DECLARE(double)
DECLARE(float)
